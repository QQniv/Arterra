/* =========================================================
   Arterra — app.js (v1)
   Логика анимаций и интерактивов
   ========================================================= */

// ---------- 1. Sticky header background on scroll ----------
const header = document.querySelector('.site-header');
let lastScroll = 0;
window.addEventListener('scroll', () => {
  const y = window.scrollY;
  if (y > 20 && y > lastScroll) header.classList.add('scrolled');
  else if (y < 20) header.classList.remove('scrolled');
  lastScroll = y;
});

// ---------- 2. Mobile menu toggle ----------
const menuBtn = document.getElementById('menuToggle');
const drawer = document.getElementById('mobileDrawer');
if (menuBtn && drawer) {
  const toggle = (open) => {
    const isOpen = open ?? drawer.hidden;
    drawer.hidden = !isOpen;
    document.body.classList.toggle('menu-open', isOpen);
    menuBtn.setAttribute('aria-expanded', String(isOpen));
  };
  menuBtn.addEventListener('click', () => toggle());
  drawer.querySelectorAll('a').forEach((a) =>
    a.addEventListener('click', () => toggle(false))
  );
}

// ---------- 3. Smooth reveal animation ----------
const revealEls = document.querySelectorAll('[data-reveal]');
const ioReveal = new IntersectionObserver(
  (entries) => {
    entries.forEach((e) => {
      if (e.isIntersecting) {
        const el = e.target;
        const delay = parseFloat(el.dataset.delay || 0);
        el.style.transition = `opacity .8s cubic-bezier(.16,1,.3,1) ${delay}s, transform .8s cubic-bezier(.16,1,.3,1) ${delay}s`;
        el.style.opacity = 1;
        el.style.transform = 'none';
        ioReveal.unobserve(el);
      }
    });
  },
  { threshold: 0.2 }
);
revealEls.forEach((el) => ioReveal.observe(el));

// ---------- 4. Staggered appearance ----------
const staggerContainers = document.querySelectorAll('[data-stagger]');
staggerContainers.forEach((container) => {
  const children = container.children;
  const delay = parseFloat(container.dataset.delay || 0);
  const step = 0.08;
  Array.from(children).forEach((el, i) => {
    el.dataset.delay = (delay + i * step).toFixed(2);
    el.setAttribute('data-reveal', '');
  });
});

// ---------- 5. Parallax scroll ----------
const parallaxEls = document.querySelectorAll('[data-parallax]');
if (parallaxEls.length) {
  let ticking = false;
  const applyParallax = () => {
    parallaxEls.forEach((el) => {
      const speed = parseFloat(el.dataset.speed || 0.15);
      const rect = el.getBoundingClientRect();
      const offset = rect.top + rect.height / 2 - window.innerHeight / 2;
      el.style.transform = `translate3d(0, ${offset * speed}px, 0)`;
    });
    ticking = false;
  };
  window.addEventListener(
    'scroll',
    () => {
      if (!ticking) {
        window.requestAnimationFrame(applyParallax);
        ticking = true;
      }
    },
    { passive: true }
  );
  applyParallax();
}

// ---------- 6. Magnetic elements ----------
document.querySelectorAll('[data-magnetic]').forEach((el) => {
  const strength = 0.25;
  const radius = 120;
  el.addEventListener('mousemove', (e) => {
    const rect = el.getBoundingClientRect();
    const dx = e.clientX - (rect.left + rect.width / 2);
    const dy = e.clientY - (rect.top + rect.height / 2);
    const dist = Math.hypot(dx, dy);
    if (dist < radius) {
      el.style.transform = `translate(${dx * strength}px, ${dy * strength}px)`;
    }
  });
  el.addEventListener('mouseleave', () => {
    el.style.transform = '';
  });
});

// ---------- 7. Count-up metrics ----------
const counters = document.querySelectorAll('[data-countup]');
const ioCount = new IntersectionObserver(
  (entries) => {
    entries.forEach((e) => {
      if (e.isIntersecting) {
        const el = e.target;
        const to = parseFloat(el.dataset.to || 0);
        const suffix = el.dataset.suffix || '';
        const duration = 1600;
        const start = performance.now();
        const animate = (t) => {
          const progress = Math.min(1, (t - start) / duration);
          const eased = 1 - Math.pow(1 - progress, 3);
          const value = Math.round(to * eased);
          el.textContent = `${value}${suffix}`;
          if (progress < 1) requestAnimationFrame(animate);
        };
        requestAnimationFrame(animate);
        ioCount.unobserve(el);
      }
    });
  },
  { threshold: 0.6 }
);
counters.forEach((el) => ioCount.observe(el));

// ---------- 8. Marquee (infinite scroll logos) ----------
const marquees = document.querySelectorAll('[data-marquee]');
marquees.forEach((mq) => {
  const speed = parseFloat(mq.dataset.speed || 60);
  const track = mq.querySelector('.marquee__track');
  if (!track) return;
  let offset = 0;
  const step = () => {
    offset -= speed / 60;
    if (offset <= -track.scrollWidth / 2) offset = 0;
    track.style.transform = `translate3d(${offset}px,0,0)`;
    requestAnimationFrame(step);
  };
  step();
});

// ---------- 9. Update year ----------
document.getElementById('year').textContent = new Date().getFullYear();

// ---------- 10. Canvas / 3D placeholder (for future bean model) ----------
const beanCanvas = document.getElementById('beanCanvas');
if (beanCanvas) {
  const ctx = beanCanvas.getContext('2d');
  const w = (beanCanvas.width = beanCanvas.clientWidth * 2);
  const h = (beanCanvas.height = beanCanvas.clientHeight * 2);
  ctx.scale(2, 2);

  // Простая placeholder-анимация: мягкий световой круг
  let t = 0;
  const loop = () => {
    ctx.clearRect(0, 0, w, h);
    const r = 80 + Math.sin(t) * 10;
    const g = ctx.createRadialGradient(w / 4, h / 3, 0, w / 2, h / 2, r);
    g.addColorStop(0, 'rgba(110,224,255,0.15)');
    g.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, w, h);
    t += 0.02;
    requestAnimationFrame(loop);
  };
  loop();
}
